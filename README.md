# c
下面都是思路
1. ## 求链表的倒数第m个元素
   方法就是双指针法，当一个指针走了相当长的距离后，另一个指针开始行动。
2. ## 单链表的分段逆转
   是有一种比较有意思的算法，但经典的就是双指针法，也可以进行递归的方法，思路比较清晰
3. ## 一个数组中的两个堆栈
   有多种存法，一般来说，数组是固定的，因此向中间生长是最好的存储结构
4. ## 后缀表达式求值
   跟中缀，前缀一样，用到栈，而且有特殊的规则，中缀注意括号的问题
5. ## 查找子串的kmp算法
   这个忘了可真的是可惜了啊，白花了那么长的时间，关键是一个特别固定的算法，也特别简单，但原理不是很容易懂，新建一个标志数组，然后设定几个变量，然后开始遍历，当出现不同的时候转移到前面的，采用了同时进行法
6. ## 最低的 共同祖先
   我是采用的一个GetParent函数，节点有高度标志，或者用GetHeight就行了，然后是等着上来，在同一高度后进行判断，或者同时上移
7. ## AVL插入
   恶心我好几天的，所幸的是好好的钻研了一下，连删除都会了，做法是递归，或者用栈，几个旋转，都不是很难了
8. ## Pop Sequence
   这个就连题意都不太好懂，是一串1，2，3，4.的序列，是否能通过有限栈得到预定的队列的，关键是在于防止数据被掩盖，就是这样，关键在与判断错误，就是这样
   这道题我没做，，怪不得,这个题可以说是充分榨干了调试的所有能力
9. ## 矩阵加法，乘法以及其他矩阵运算
0. ## 有一个每一列的首元素的地址的数组
1. ## 树的同构
   树的同构说的是子树的左右互换是没有关系的，判断两棵树是不是这样的同构，递归比较返回false或者ture，就是那个if超级多的那个
2. ## 部落
    是并查集的题，有两个函数find和merge，分别是获得祖先和融合祖先，每个节点只存祖先
3. ## 自上而下，自左而右的列出所有叶子节点
    就是层序输出
4. ## 霍夫曼代码
    首先只是求根节点的大小或者别的，首先是带权路径长度，WPL，是该节点到树根之间的长度与该节点上权的乘积，注意是叶子节点，路径是根节点到叶子节点之间有多少的连线，一般说来，他们的父节点的值是两个子节点的权的和，那么根节点的值就是所有叶子节点的权值之和，那么如何构造呢？哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不惟一，哈夫曼树的结点的度数为 0 或 2， 没有度为 1 的结点。包含 n 个叶子结点的哈夫曼树中共有 2n – 1 个结点。包含 n 棵树的森林要经过 n–1 次合并才能形成哈夫曼树，共产生 n–1 个新结点，那么问题来了，就可以用set来算，或者每次排一下序，或者用最小堆来算，只要原理是这样就行，每次取两个小的，然后相加，填入里面，直到最后为1，就可以了，但霍夫曼编码如何解决前缀编码重复的问题呢？任意一个叶子结点都不可能在其它叶子结点的路径中。霍夫曼树最好用三叉链表来做，比对有没有前缀重复我用的是string的find进行子串查询，另外，是需要从头开始比对的，但是find会返回下标的，判断是不是0就可以了，查不到返回 4294967295，表示无符号整数的十进制最大值，十位数。，求wpl我用的是vector+sort，没有实现哈夫曼树
5. ## 最小堆
    首先，堆都是从0开始的，然后，每次添加一个数，只要调整这一个链的值就可以了，一直能调整到根节点，就是这样，当查询时，只可能要跟节点，那才是有意义的，根节点提取出来后必须进行调整，  
6. ## bitmap排序
    是利用位置进行的排序，和利用时间进行排序有异曲同工之妙，就是利用一个bit位，存储0或者1，然后按照顺序输出就可以了，思想挺巧妙的，    但是需要要求数的大小和数量与开辟的总空间差不多才行，这样最好，可以运用在快速查找、去重、排序、压缩数据等。但是在c语言中，最低也要开一个byte，bit是不能实现的，所以现在设一个int也只不过是/32的问题，假设最大值为n，那么就设int a[n/32 + 1]即可，注意其中a[0]对应的是0-31，用位移的方法将十进制数转换为对应的bit位，由于归纳可知，一个数n会被限制在a[n/32]这32个数之内，给定一个数可以通过模32求得在对应数组a[i]中的下标
    ```
    a[n/32] |= 1 << n%32
    ```
    挺高大上的说，通过移位操作实现置1
    row = n/32 完全等价于 row = n >> 5
    1<<n/32 完全等价于 n & 0x1f，就是这样
    判断的话就是做交运算，a[n/32]&(1<<n/32)，看看是否为0就可以了

7. ## 欧拉回路
    一是判断是不是孤立点（度为0），二是判断度是不是偶数，就是这么简单。

8. ## 汉密尔顿回路
    这个就不怎么有什么窍门了，首先用邻接矩阵存储图，然后将每一个点作为起点，递归求得路径，进行判断是否能到头，就是这样

9. ## 六度空间
    没有A过，所以讲一下解法，就是用一个六层循环，循环到头正好是六层，我当时应该是这么做的

0. ## 逆散列问题
    给定一个哈希表，确定它的插入顺序？不会，而且网上也没有相关的博客

1. ## 普里姆算法求最小生成树
    从一个点开始，不断求其连向外的最短路径，直到生成这个最小生成树

2. ## 克鲁斯卡尔算法求最小生成树
    用的是线段，先pop出一个最小的线段，看它是否在两个连通分量之间，不是则抛弃

    ### 迪杰斯特拉算法求最短路径
        就是绕圈取最小值的方法
        
    ### 弗洛伊德算法求最小路径
        就是不断遍历损失信息的那个算法

3. ## AOV-网 activity on vertices
    用顶点表示活动，用弧表示活动的优先关系的有向图称为定点表示活动的网
    首先判断它不应该有有向环，检测的办法是对有向图构造其顶点的拓扑有序序列，所有点都在它的拓扑有序序列中，则必定不存在环。检查拓扑排序的算法是：在有向图中选一个没有前驱的顶点且输出之，从图中删除该顶点和所有以它为尾的弧，重复以上的步骤，直到全部定点均以输出，或者当前图中不存在无前驱的顶点为止，后一种情况则说明有向图中存在环。AOV-网好像只是解决的问题是判断是否拓扑有序

4. ## AOE-网 activity on edges
    边表示活动，弧上的权表示持续的时间，顶点表示事件。
    问题1.求关键路径：时间最短路径
    问题2.求长度最短路径，就是最短路径：迪杰斯特拉算法，即从一个顶点开始，按路径长度递增的次序产生最短路径，弗洛伊德算法，先选择一个起点和一个终点，然后往里面填入顶点，这样可以求得任意两个顶点之间的最短距离，因为只是输出最短路径（应该也应该打印出来的路径），e[i][j]是最小的值，填入最小的值,是所有节点都通过1的最小值,肯定有一些节点被更新了，最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。也就是说，非常简单，只不过是经过从0到n-1的循环，然后就成了，但是没有节点的信息。
    只有这个求关键路径的过程，这个法那个法都是求最小路径的

5. ## 完全二叉树
    除树叶外，每个节点都有两个儿子的根树称为完全二叉树，也就是说，不是最矮的，完美二叉树是说的是最矮的然后有2^(k+1)-1的那种树，深度说的是边数，是节点数减1，完全二叉树数据结构上与离散数学上讲的不一样，数据结构讲的是最矮的，完满二叉树才是每个节点都有两个儿子的树

6. ## B树
    插入是向上分裂，只有一种情况，但是删除要分三种情况，如果是不是最下层的非叶子节点，则需要把此关键字与它在B树中的后继对换位置，即在子树中的最小关键字代替这个值，然后在相应的结点中删除Y。如果是最下层的非叶子节点，那么就会有两种可能，自己够用，则直接删除即可，自己不够用，则从兄弟节点中通过循环的办法移动一个，倘若兄弟节点也少，则合并为一个节点

7. ## 拓扑排序
    实际上就是不能有元素放到之前的位置，一般按照字母的顺序进行排列