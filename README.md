# c
下面都是思路
1. ## 求链表的倒数第m个元素
   方法就是双指针法，当一个指针走了相当长的距离后，另一个指针开始行动。
2. ## 单链表的分段逆转
   是有一种比较有意思的算法，但经典的就是双指针法，也可以进行递归的方法，思路比较清晰
3. ## 一个数组中的两个堆栈
   有多种存法，一般来说，数组是固定的，因此向中间生长是最好的存储结构
4. ## 后缀表达式求值
   跟中缀，前缀一样，用到栈，而且有特殊的规则，中缀注意括号的问题
5. ## 查找子串的kmp算法
   这个忘了可真的是可惜了啊，白花了那么长的时间，关键是一个特别固定的算法，也特别简单，但原理不是很容易懂，新建一个标志数组，然后设定几个变量，然后开始遍历，当出现不同的时候转移到前面的，采用了同时进行法
6. ## 最低的 共同祖先
   我是采用的一个GetParent函数，节点有高度标志，或者用GetHeight就行了，然后是等着上来，在同一高度后进行判断，或者同时上移
7. ## AVL插入
   恶心我好几天的，所幸的是好好的钻研了一下，连删除都会了，做法是递归，或者用栈，几个旋转，都不是很难了
8. ## Pop Sequence
   这个就连题意都不太好懂，是一串1，2，3，4.的序列，是否能通过有限栈得到预定的队列的，关键是在于防止数据被掩盖，就是这样，关键在与判断错误，就是这样
   这道题我没做，，怪不得,这个题可以说是充分榨干了调试的所有能力
9. ## 矩阵加法，乘法以及其他矩阵运算
0. ## 有一个每一列的首元素的地址的数组
1. ## 树的同构
   树的同构说的是子树的左右互换是没有关系的，判断两棵树是不是这样的同构，递归比较返回false或者ture，就是那个if超级多的那个
2. ## 部落
    是并查集的题，有两个函数find和merge，分别是获得祖先和融合祖先，每个节点只存祖先
3. ## 自上而下，自左而右的列出所有叶子节点
    就是层序输出
4. ## 霍夫曼代码
    首先只是求根节点的大小或者别的，首先是带权路径长度，WPL，是该节点到树根之间的长度与该节点上权的乘积，注意是叶子节点，路径是根节点到叶子节点之间有多少的连线，一般说来，他们的父节点的值是两个子节点的权的和，那么根节点的值就是所有叶子节点的权值之和，那么如何构造呢？哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不惟一，哈夫曼树的结点的度数为 0 或 2， 没有度为 1 的结点。包含 n 个叶子结点的哈夫曼树中共有 2n – 1 个结点。包含 n 棵树的森林要经过 n–1 次合并才能形成哈夫曼树，共产生 n–1 个新结点，那么问题来了，就可以用set来算，或者每次排一下序，或者用最小堆来算，只要原理是这样就行，每次取两个小的，然后相加，填入里面，直到最后为1，就可以了，但霍夫曼编码如何解决前缀编码重复的问题呢？任意一个叶子结点都不可能在其它叶子结点的路径中。霍夫曼树最好用三叉链表来做，比对有没有前缀重复我用的是string的find进行子串查询，另外，是需要从头开始比对的，但是find会返回下标的，判断是不是0就可以了，查不到返回 4294967295，表示无符号整数的十进制最大值，十位数。，求wpl我用的是vector+sort，没有实现哈夫曼树
5. ## 最小堆
    首先，堆都是从0开始的，然后，每次添加一个数，只要调整这一个链的值就可以了，一直能调整到根节点，就是这样，当查询时，只可能要跟节点，那才是有意义的，根节点提取出来后必须进行调整，  
6. ## bitmap排序
    是利用位置进行的排序，和利用时间进行排序有异曲同工之妙，就是利用一个bit位，存储0或者1，然后按照顺序输出就可以了，思想挺巧妙的，    但是需要要求数的大小和数量与开辟的总空间差不多才行，这样最好，可以运用在快速查找、去重、排序、压缩数据等。但是在c语言中，最低也要开一个byte，bit是不能实现的，所以现在设一个int也只不过是/32的问题，假设最大值为n，那么就设int a[n/32 + 1]即可，注意其中a[0]对应的是0-31，用位移的方法将十进制数转换为对应的bit位，由于归纳可知，一个数n会被限制在a[n/32]这32个数之内，给定一个数可以通过模32求得在对应数组a[i]中的下标
    ```
    a[n/32] |= 1 << n%32
    ```
    挺高大上的说，通过移位操作实现置1
    row = n/32 完全等价于 row = n >> 5
    1<<n/32 完全等价于 n & 0x1f，就是这样
    判断的话就是做交运算，a[n/32]&(1<<n/32)，看看是否为0就可以了

7. ## 欧拉回路
    一是判断是不是孤立点（度为0），二是判断度是不是偶数，就是这么简单。

8. ## 汉密尔顿回路
    这个就不怎么有什么窍门了，首先用邻接矩阵存储图，然后将每一个点作为起点，递归求得路径，进行判断是否能到头，就是这样

9. ## 六度空间
    没有A过，所以讲一下解法，就是用一个六层循环，循环到头正好是六层，我当时应该是这么做的

0. ## 逆散列问题
    给定一个哈希表，确定它的插入顺序？不会，而且网上也没有相关的博客

1. ## 普里姆算法求最小生成树
    从一个点开始，不断求其连向外的最短路径，直到生成这个最小生成树

22. ## 克鲁斯卡尔算法求最小生成树
     用的是线段，先pop出一个最小的线段，看它是否在两个连通分量之间，不是则抛弃

     ### 迪杰斯特拉算法求最短路径
     ```c
     就是绕圈取最小值的方法
     ```

     ### 弗洛伊德算法求最小路径
         就是不断遍历损失信息的那个算法

3. ## AOV-网 activity on vertices
    用顶点表示活动，用弧表示活动的优先关系的有向图称为定点表示活动的网
    首先判断它不应该有有向环，检测的办法是对有向图构造其顶点的拓扑有序序列，所有点都在它的拓扑有序序列中，则必定不存在环。检查拓扑排序的算法是：在有向图中选一个没有前驱的顶点且输出之，从图中删除该顶点和所有以它为尾的弧，重复以上的步骤，直到全部定点均以输出，或者当前图中不存在无前驱的顶点为止，后一种情况则说明有向图中存在环。AOV-网好像只是解决的问题是判断是否拓扑有序

4. ## AOE-网 activity on edges
    边表示活动，弧上的权表示持续的时间，顶点表示事件。
    问题1.求关键路径：时间最短路径
    问题2.求长度最短路径，就是最短路径：迪杰斯特拉算法，即从一个顶点开始，按路径长度递增的次序产生最短路径，弗洛伊德算法，先选择一个起点和一个终点，然后往里面填入顶点，这样可以求得任意两个顶点之间的最短距离，因为只是输出最短路径（应该也应该打印出来的路径），e[i][j]是最小的值，填入最小的值,是所有节点都通过1的最小值,肯定有一些节点被更新了，最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。也就是说，非常简单，只不过是经过从0到n-1的循环，然后就成了，但是没有节点的信息。
    只有这个求关键路径的过程，这个法那个法都是求最小路径的

5. ## 完全二叉树
    除树叶外，每个节点都有两个儿子的根树称为完全二叉树，也就是说，不是最矮的，完美二叉树是说的是最矮的然后有2^(k+1)-1的那种树，深度说的是边数，是节点数减1，完全二叉树数据结构上与离散数学上讲的不一样，数据结构讲的是最矮的，完满二叉树才是每个节点都有两个儿子的树

6. ## B树
    插入是向上分裂，只有一种情况，但是删除要分三种情况，如果是不是最下层的非叶子节点，则需要把此关键字与它在B树中的后继对换位置，即在子树中的最小关键字代替这个值，然后在相应的结点中删除Y。如果是最下层的非叶子节点，那么就会有两种可能，自己够用，则直接删除即可，自己不够用，则从兄弟节点中通过循环的办法移动一个，倘若兄弟节点也少，则合并为一个节点

7. ## 拓扑排序
    实际上就是不能有元素放到之前的位置，一般按照字母的顺序进行排列

8. ## 汉密尔顿回路
    真的忘记了

9. ## 欧拉回路

0. ## 六度空间
    用队列的方法，邻接表是一维数组，元素全都是链表

1. ## 家庭成员
    并查集，嗯，是一个全局变量，只存储根节点，有find函数用来获得根节点和一个merge函数用来合并根节点

# 哈希表
---
+ 设计一个好的哈希函数
+ 设计一种能有效处理冲突的方法
  ## 常用哈希函数构造法
  + ### 直接地址法
    取关键字或它的某个线性函数值为哈希地址，就是线性函数，简单，均匀，不会产生冲突，但实际不常用
  + ### 数字分析法
    预先都知道关键字，则可以关键字的若干数位组成哈希地址
  + ### 平方取中法
    先求关键字的平方 ，在根据表长取出中间几位作为哈希地址，适用于关键字分布未知，且关键字的个数不是很多
  + ### 折叠法
    将关键字分割成位数相同的几部分，（最后一部分的可以不相同），然后取出这几部分的叠加和（舍去进位）作为哈希地址），适用于关键字位数很多，且关键字每位上的数字分布大致均匀的情况
  + ### 基数转换法
    先把关键字看成基数为r
    1的数，然后将它转换成基数为r2的数，再选取其中几位作为哈希地址
  + ### 除数留余法
    选择某个不大于表长的数p，取关键字后除以p以后所得到的余数为哈希地址，可以直接取模，也可以折叠，平方之后取模，p应当选取质数，否则关键字被映射到0-p-1范围内的均匀度将大幅降低，发生冲突的概率随着p所含质因子的增多而迅速增大
  + ### 伪随机数法
    选择一个随机函数，取关键字的随机函数值为其哈希地址，对，是C语言为随机函数的性质决定的，通常当关键字的长度不等的时候，采用此法较恰当，不能用于两个语言系统
## 处理冲突
### 闭散列方法/开放定址法和开散列方法/封闭定址法
### 闭散列方法/开放地址法
对于处理冲突而言，它的目的仅仅是为了把数据插进去，ASLs为成功时的平均查找长度，表中平均查找次数（冲突次数+1）
不成功时的平均查找长度ASLu，不在表中的关键字（按地址分类）的平均查找次数
状态因子a为为关键字个数除以表长
+ 线性探测再散列
  处理冲突的过程中可能得到一个地址序列：Hi = (H(key)+di)mod m,其中，i表示不成功后的增量，所以说，只是插进去完事，di取1，2，3，4，5，6什么的就足够了啊。。改进就是改变步长，或者说是二次探查再散列，实质上是把步长改成-1，1，-2, 2 1^2, 2^2, 3^2就是这样，或者说，线性探测再散列就是用+——1，+——2，二次探查再散列就是加上平方正负， 但只有在哈希表长m为素数的时候才可能解决问题？有聚焦问题严重的问题，线性探测就是逐个检查冲突位置的下一个位置，就是这样
  ## 开放地址法-线性探测再散列
  + 线性探测再散列：
     + 缺点是冲突加剧，最坏的时候可能达到o(n)的代价
     + 优点是只要哈希表未满，总能找到一个不发生冲突的地址。
     + 一般来说，只是加一个1表示散列表的位置
     + 除余后的那个就是地址，如果被占用了就加1再进行判断
  H(key)=(key+2)mod11貌似是一个十分重要的函数
  + 二次探测再散列
     + 第二个散列函数要仔细选择，需要满足条件： 1.排除散列值为0的情况 2.产生的散列值必须与表长M互素
     + 其实就是把di换成了di*h（2）就是这样了
  + 双散列探测法
    + 用另一个hashing函数作为步长进行探测
  + 再哈希法
在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生，不易产生聚焦，但增加了计算的时间，也就是说，采用了许多不同的哈希函数，但是，这个是真的能有漏洞
+ 链地址法
将所有的哈希地址为i的记录存储在同一条线性表（同义词链），并将链表的头指针存储在哈希表的第i个单元中。
+ 公共溢出区法
若哈希函数的值域为[0, m-1],则设一个同等大小的基本表，另设一个溢出表，但凡与基本表发生冲突的记录，一律填入溢出表

# KMP算法

采用部分匹配的思想，比较烧脑，只有看代码才能明白
```
void next(char s[], int next[], int n){
    next[0] = -1;
    int i = 0, j = -1;//相当于父串指针，子川指针
    //从1位置开始比较
    while(i < n){
        if(j==-1 || p[i]==p[j]){//匹配或者到底时，前进
            next[++i] = ++j;
            //是这样，最难懂的
            //它是说只能赋值后面的，因为现在是重了的
            //一石n鸟的感觉
        }else{
            j = next[j];//不匹配时，自身回溯
        }
    }
}
```
# 冒泡排序
>比较相邻的元素，那么到达最后的那一个元素就是最大或者最小的元素，就这样比较直到没有元素，或者称为石头排序，向下排序

*[冒泡排序]:看来也不支持注释

代码为：
```
for(int i=L.Length; i>0; i--){
    for(int j=1; j<i; j++){
        if(L.elem[j] > L.elem[j+1]){
            int t = L.elem[j];
            L.elem[j] = L.elem[j+1];
            L.elem[j+1] = t;
        }
```
# 直接插入排序
>是稳定排序，每次拿出上一个，纳入哨兵中，会有记录后移
>更好的方式是折半查询，但如果有重复的，需要进行相等判断，把相等和大于的合并
>插入排序改的是已经排好的列表，是随便从未插入的混乱列表中随机选取的
>所以插入排序可以用二分法进行排序，而普通排序则不能
>2-路插入排序，将一个中位数当作标志，前后插，空间复杂度增大，时间复杂度也只是/2而已

做法是对于每个从第二个元素开始，在已排好序列中进行二分查找，然后进行元素移动，最后插入
# 表插入排序
>最重要的是排好序的链表转换成顺序表，关键是保持交换后链表不中断的方法，能够一直找到后继，然后进行交换
# 希尔排序 
>是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。第一个缩小增量的排序，理解成缩小增量的插入排序，偶偶希尔排序不是简单粗暴的分成两块，而是那种分隔的那种插入，首先步长挺大的，然后逐渐缩小到1，步长怎么选有讲究，但是一般开始选1/2的那种，最后一定要做一趟步长为1的直接插入

做法是用两个函数，总函数是确定步长，小函数是一个简单插入，是简单插入的加上步长而已
# 堆排序
>首先要会创建最小堆，堆排序实际上就是创建最小堆的过程，堆排序是不稳定的，不是大顶堆，之前做过，现在忘了， 先构造一个大顶堆，然后将这个大顶堆变换成一个有序序列，就是这样，分成两个函数
# 表排序
>又称间接排序，排序时不调整元素的实际位置，而是定义一个额外的数组作为“表”（table）。根据元素的关键字大小来调整元素对应下标在表中的位置。表排序在调整下标的位置时可以使用其他的排序算法，例如直接插入排序。然后进行堆的缩小，同时满足堆的定义
>完全二叉树通常选择采用顺序存储结构的方式，但关键是，二叉树是如何存进去的呢？其实就是按照层序输入的，那么第一个元素就是根元素每一个元素的父节点就是它位置的一半，但应该从0开始不是吗？不，实践证明从1开始，如果从0开始呢？就错位了，不能运行的那种，一般升序采用大顶堆，降序采用小顶堆
```c
void HeapSort( HeapType  H) { 
  int i; KeyType rc;
  for(i=H.Length/2; i>0; i--) {
      //是所有中间节点调整一遍，因为这个堆排序只能排一个链
      HeapAdjust(H, i, H.Length);
   }
  for(i=H.Length;i>1;i--) {
      rc=H.elem[1];
      H.elem[1]=H.elem[i]; 
      H.elem[i]=rc;
      //因为根会被每一条链遍历到，所以可行
      HeapAdjust(H, 1, i-1); 
   }
 }
void HeapAdjust(HeapType H, int s, int m){
    int node = s;
    int child = node*2;
    while (child <= m) {
        if (child+1<=m && H.elem[child]<H.elem[child+1])
            child += 1;
        if (H.elem[node] > H.elem[child]) 
            return;
        else { 
            int t = H.elem[node];
            H.elem[node] = H.elem[child];
            H.elem[child] = t;
            node = child;
            child = node*2;
        }
    }
}
```
# 归并排序
>时间复杂度比较小，是稳定排序，进行拆散，然后合并的时候进行队伍排序，从小的往回来的时候进行排序
# 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法
不稳定的排序算法有：快、希、选、堆。冒，归，插，基是稳定排序,如果有步长大于1的一定是不稳定排序，on2一般都是稳定的，nlogn一般都是不稳定的

|---------------+---------------|
|               |               |
|---------------+---------------|
# 快速排序
>快速排序是对冒泡排序的一种改进。步长叫pivot
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。但也不见得与冒泡排序有什么一样的地方，可能有递归，并不是很简单，从右往左找到小的，插入到左边，用字表的第一个元素作为哨兵之类的

问题是不能有顺序，最杂乱就好了,那么取中间，前端，后端的元素进行比较一下，取中就会是一个改进，空间复杂度是先割小的，那么会减少一倍复杂度。。。

首先要找到一个切入点，一般是第一个，然后找到所有的小于这个切入点的数据插到左边，然后就可以进行递归操作,而且插入排序有相当好的性能，理解成缩小增量的冒泡排序

# 基数排序
>某些时候，基数排序的效率还是蛮高的,比较有意思的一种算法，通过排列从个位到十位以至于到最高位的数字，进行排序，不是稳定排序

# 选择排序
>每次遍历一遍，将最大值或最小值遍历出来，然后顺序排好，就是这样，实际上，不是你常用的那一个，这个是稳定排序，关键就在于找到相同的数据后插入到后面，是这样没错了，这个才是你喜欢的那种排序,额，我喜欢哪个排序来着？好像就是这个吧。。

# 树形选择排序
>所有的叶节点是所有元素，然后赢了进行上一层，一直到根节点，而且位子需要作废，然后重新选冠军,对n个关键字进行两两排序，然后再进行两两比较，如此重复直到选出最小关键字的记录为止，但堆排序对各个地方都比这个好，所以它就被掩盖住了，它是稳定排序

# 堆排序
>首先怎么办才能构建堆？它是从0开始的一维数组，然后要从第一个非叶节点开始（也可以从开头进行开始啊，复杂度没那么简单而已），到最后一个节点结束，如何将堆转换成序列，就是这样，只有非叶子节点不满足堆定义，堆定义是父节点大于两个子节点，去交换，HeapAdjust一次只调整一列，进行往下走。。。不怎么明白了，最后一步是直接交换，然后是相同的调整，就是这样

# 多关键字排序

# 插入排序包括简单插入排序，折半插入排序，2-路插入排序，表插入，希尔排序，希尔排序是那种间隔的，它是用了插入排序的方法了，交换排序包括气泡排序和快速排序，快速排序是那种，上面讲的够详细，选择排序包括简单选择排序，树形排序和堆排序
