# c
下面都是思路
1. ## 求链表的倒数第m个元素
   方法就是双指针法，当一个指针走了相当长的距离后，另一个指针开始行动。
2. ## 单链表的分段逆转
   是有一种比较有意思的算法，但经典的就是双指针法，也可以进行递归的方法，思路比较清晰
3. ## 一个数组中的两个堆栈
   有多种存法，一般来说，数组是固定的，因此向中间生长是最好的存储结构
4. ## 后缀表达式求值
   跟中缀，前缀一样，用到栈，而且有特殊的规则，中缀注意括号的问题
5. ## 查找子串的kmp算法
   这个忘了可真的是可惜了啊，白花了那么长的时间，关键是一个特别固定的算法，也特别简单，但原理不是很容易懂，新建一个标志数组，然后设定几个变量，然后开始遍历，当出现不同的时候转移到前面的，采用了同时进行法
6. ## 最低的 共同祖先
   我是采用的一个GetParent函数，节点有高度标志，或者用GetHeight就行了，然后是等着上来，在同一高度后进行判断，或者同时上移
7. ## AVL插入
   恶心我好几天的，所幸的是好好的钻研了一下，连删除都会了，做法是递归，或者用栈，几个旋转，都不是很难了
8. ## Pop Sequence
   这个就连题意都不太好懂，是一串1，2，3，4.的序列，是否能通过有限栈得到预定的队列的，关键是在于防止数据被掩盖，就是这样，关键在与判断错误，就是这样
   这道题我没做，，怪不得,这个题可以说是充分榨干了调试的所有能力
9. ## 矩阵加法，乘法以及其他矩阵运算
10. ## 有一个每一列的首元素的地址的数组
11. ## 树的同构
   树的同构说的是子树的左右互换是没有关系的，判断两棵树是不是这样的同构，递归比较返回false或者ture，就是那个if超级多的那个
12. ## 部落
    是并查集的题，有两个函数find和merge，分别是获得祖先和融合祖先，每个节点只存祖先
13. ## 自上而下，自左而右的列出所有叶子节点
    就是层序输出
14. ## 霍夫曼代码
    首先只是求根节点的大小或者别的，首先是带权路径长度，WPL，是该节点到树根之间的长度与该节点上权的乘积，注意是叶子节点，路径是根节点到叶子节点之间有多少的连线，一般说来，他们的父节点的值是两个子节点的权的和，那么根节点的值就是所有叶子节点的权值之和，那么如何构造呢？哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不惟一，哈夫曼树的结点的度数为 0 或 2， 没有度为 1 的结点。包含 n 个叶子结点的哈夫曼树中共有 2n – 1 个结点。包含 n 棵树的森林要经过 n–1 次合并才能形成哈夫曼树，共产生 n–1 个新结点，那么问题来了，就可以用set来算，或者每次排一下序，或者用最小堆来算，只要原理是这样就行，每次取两个小的，然后相加，填入里面，直到最后为1，就可以了，但霍夫曼编码如何解决前缀编码重复的问题呢？任意一个叶子结点都不可能在其它叶子结点的路径中。霍夫曼树最好用三叉链表来做，比对有没有前缀重复我用的是string的find进行子串查询，另外，是需要从头开始比对的，但是find会返回下标的，判断是不是0就可以了，查不到返回 4294967295，表示无符号整数的十进制最大值，十位数。，求wpl我用的是vector+sort，没有实现哈夫曼树
15. ## 最小堆
    首先，堆都是从0开始的，然后，每次添加一个数，只要调整这一个链的值就可以了，一直能调整到根节点，就是这样，当查询时，只可能要跟节点，那才是有意义的，根节点提取出来后必须进行调整，